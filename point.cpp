#include <stdio.h>

// 地址的概念可以理解为能级或者层级, 指针看作一个装地址的容器 ,地址就是内容
// 操作时*降低一个层级,&提高一个层级,定义时*为一级,**为二级,赋值需要层层对应

// [函数传 指针 参数]
// (在做函数参数时)char *a 等价于 char a[]
void func01(char *a)
{
    a[1] = 'F';
}

// [函数传 数组指针 参数]
void func02(int (*a)[3])
{
    a[1][1] = 100;
}

// [函数传 指针数组 参数](数组内为非数组)
void func03(int **a)
{
    *a[1] = 700;
}

// [函数传 指针数组 参数](数组内为数组)
void func04(int **a)
{
    a[3][0] = 900;
}

// 所有指针变量在64位上为8字节,32位上为4字节,但不能混着用,因为不同类型指针的操作权限不同,如char*只操作一个字节,只能位移一个字节
int main()
{
    // [间接指向字符串的指针] 字符串本质为数组,数组名即地址,%s可把字符串当作整体,自动寻址后续地址直到 \0 结束,%c需要用*寻址
    char c[] = "hello";
    char *cp1 = c;
    // 可修改内部
    func01(cp1);
    // *(cp1 + 1) = 'x';
    // 字符串的%s特殊,int数组不能直接遍历
    printf("\n指向字符串的指针== %s\n", cp1);
    printf("字符串的第二个元素== %c\n", *(cp1 + 1));
    printf("指针打印==");
    while (*cp1)
    {
        printf("%c", *cp1++);
    }

    // [直接指向字符串的指针]
    char *cccp = "hello";
    printf("\n\n直接指向字符串的指针==%s\n", cccp); // 可读
    // *(cccp + 1) = 'x'; //不可改
    // printf("\n\n直接指向字符串的指针==%s", cccp);
    *(&cccp) = "x";
    printf("直接指向字符串的指针==%s(重新赋值)", cccp); // 改的是整个字符串"hello",也就是重新赋值

    // [直接指向字符串数组的指针](char类型 数组指针)
    char *ccp[] = {"hello", "name"};
    printf("\n\n直接指向字符串[数组]的指针(第二个元素)==%s\n", *(ccp + 1));
    // 改的是整个字符串"name",也就是重新赋值
    *(ccp + 1) = "x";
    printf("直接指向字符串[数组]的指针(第二个元素)==%s(重新赋值)", *(ccp + 1));

    // 指向数组(首地址)的指针  数组首地址&a[0]=数组自身地址&a=指向该数组的指针的地址pa,但数组自身地址不等价数组首地址,步长不同
    // 如&a+1为下一个数组地址,步长为a的存储大小,&a[0]+1 或 pa+1 或 a+1为第二个元素a[1]地址
    int a[] = {10, 20, 30, 40};
    int *pa = a;
    printf("\n\n指向数组的指针==pa地址(指向数组a的首元素地址)：%p || 数组a的首地址：%p || 数组a的地址：%p || a的首元素元素：%d\n\n", pa, &a[0], &a, *pa);
    // 若想指向数组本身地址(&a) 需要二级指针(地址的地址)
    // 取地址后存入  地址的地址(对指针取地址&p)
    int **ppa = &pa;
    // printf("%p\n", &pa);

    // 指针数组 实际上是多个已声明的指针组成的数组,并用一个指针直接指向这个无名的数组
    // 数组指针 用指针指向已声明(有数组名)的二维数组

    /**

     数组指针(二维):
            数值地址 数组名   一维地址   地址      值

                                   &0x001   xx01..
                            &0x00  &0x002   xx02..
                                   &0x003   xx03..
                                   ......
                            &0x01  &0x010   xx10..
    p  ---> &0x0... a[][]          &0x011   xx11..
(&0xx...)                          &0x012   xx12..
                                   ......
                            &0x02  &0x020   xx20..
                            .....  ......   ......

     指针数组
            数值地址 数组名   地址    值

                           &0x00  xx00..
                           &0x01  xx01..
            &0x0... a[]    &0x02  xx02..
                           .....  ......

    */
    // 联系：如果指针数组中的【已声明的指针为数组指针】(如n1n2n3为数组),则指针数组类似特殊的数组指针(不等于),如图
    // int n1[] = {100}, n2[] = {200}, n3[] = {300};
    // int *nps[] = {{100}, {200}, {300}};

    // [指针数组] 是个数组,有自己本身的地址,指针数组的数组名实质是一个指向数组的二级指针(即指向 由多个指针组成的数组 的地址)
    int n1 = 100, n2 = 200, n3 = 300, k1[] = {111}, k2[] = {222}, k3[] = {333};
    int *pn1 = &n1, *pn2 = &n2, *pn3 = &n3, *pk1 = k1, *pk2 = k2, *pk3 = k3;
    int *nps[] = {
        pn1,
        pn2,
        pn3,
        pk1,
        pk2,
        pk3};
    func03(nps); // 改n2
    func04(nps); // 改k2[0]
    printf("指针数组====nps地址(数组自己的地址):%p ||首元素地址：%p || 首元素的值p1(n1的地址)：%p || n1地址：%p || n1的值:%d \n\n", &nps, nps, nps[0], &n1, *nps[0]);
    for (int i = 0; i < 3; i++)
    {
        printf("n%d: %d\n", i + 1, *nps[i]);
    }
    for (int i = 3; i < 6; i++)
    {
        printf("k%d[0]: %d\n", i - 2, nps[i][0]);
    }
    // [数组指针] : 二维数组指针
    int b[][3] = {
        {00, 01, 02},
        {10, 11, 12},
        {20, 21, 22}};
    int(*pb)[3] = b;
    func02(pb); // 改b[1][1]
    printf("\n======二维数组======");
    for (int i = 0; i < 3; i++)
    {
        printf("\n");
        for (int j = 0; j < 3; j++)
        {
            printf("[%d][%d] : %d ", i, j, *(*(pb + i) + j));
        }
    }
}
